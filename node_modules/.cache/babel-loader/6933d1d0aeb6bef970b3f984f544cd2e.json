{"ast":null,"code":"!function (e, r) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = r(require(\"axios\")) : \"function\" == typeof define && define.amd ? define([\"axios\"], r) : \"object\" == typeof exports ? exports[\"axios-auth-refresh\"] = r(require(\"axios\")) : e[\"axios-auth-refresh\"] = r(e.axios);\n}(this, function (e) {\n  return function () {\n    \"use strict\";\n\n    var r = {\n      593: function (e, r, t) {\n        var n = this && this.__assign || function () {\n          return n = Object.assign || function (e) {\n            for (var r, t = 1, n = arguments.length; t < n; t++) for (var s in r = arguments[t]) Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s]);\n\n            return e;\n          }, n.apply(this, arguments);\n        };\n\n        Object.defineProperty(r, \"__esModule\", {\n          value: !0\n        }), r.resendFailedRequest = r.getRetryInstance = r.unsetCache = r.createRequestQueueInterceptor = r.createRefreshCall = r.shouldInterceptError = r.mergeOptions = r.defaultOptions = void 0;\n        var s = t(300);\n        r.defaultOptions = {\n          statusCodes: [401],\n          pauseInstanceWhileRefreshing: !1\n        }, r.mergeOptions = function (e, r) {\n          return n(n(n({}, e), {\n            pauseInstanceWhileRefreshing: r.skipWhileRefreshing\n          }), r);\n        }, r.shouldInterceptError = function (e, r, t, n) {\n          var s, o;\n          return !!e && !(null === (s = e.config) || void 0 === s ? void 0 : s.skipAuthRefresh) && !!(r.interceptNetworkError && !e.response && 0 === e.request.status || e.response && (null === (o = r.statusCodes) || void 0 === o ? void 0 : o.includes(parseInt(e.response.status)))) && (e.response || (e.response = {\n            config: e.config\n          }), !r.pauseInstanceWhileRefreshing || !n.skipInstances.includes(t));\n        }, r.createRefreshCall = function (e, r, t) {\n          return t && t.refreshCall || (t.refreshCall = r(e), \"function\" == typeof t.refreshCall.then) ? t.refreshCall : (console.warn(\"axios-auth-refresh requires `refreshTokenCall` to return a promise.\"), Promise.reject());\n        }, r.createRequestQueueInterceptor = function (e, r, t) {\n          return void 0 === r.requestQueueInterceptorId && (r.requestQueueInterceptorId = e.interceptors.request.use(function (e) {\n            return (null == e ? void 0 : e.skipAuthRefresh) ? e : r.refreshCall.catch(function () {\n              throw new s.default.Cancel(\"Request call failed\");\n            }).then(function () {\n              return t.onRetry ? t.onRetry(e) : e;\n            });\n          })), r.requestQueueInterceptorId;\n        }, r.unsetCache = function (e, r) {\n          e.interceptors.request.eject(r.requestQueueInterceptorId), r.requestQueueInterceptorId = void 0, r.refreshCall = void 0, r.skipInstances = r.skipInstances.filter(function (r) {\n            return r !== e;\n          });\n        }, r.getRetryInstance = function (e, r) {\n          return r.retryInstance || e;\n        }, r.resendFailedRequest = function (e, r) {\n          return e.config.skipAuthRefresh = !0, r(e.response.config);\n        };\n      },\n      300: function (r) {\n        r.exports = e;\n      }\n    },\n        t = {};\n\n    function n(e) {\n      var s = t[e];\n      if (void 0 !== s) return s.exports;\n      var o = t[e] = {\n        exports: {}\n      };\n      return r[e].call(o.exports, o, o.exports, n), o.exports;\n    }\n\n    var s = {};\n    return function () {\n      var e = s;\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n      var r = n(593);\n\n      e.default = function (e, t, n) {\n        if (void 0 === n && (n = {}), \"function\" != typeof t) throw new Error(\"axios-auth-refresh requires `refreshAuthCall` to be a function that returns a promise.\");\n        var s = {\n          skipInstances: [],\n          refreshCall: void 0,\n          requestQueueInterceptorId: void 0\n        };\n        return e.interceptors.response.use(function (e) {\n          return e;\n        }, function (o) {\n          if (n = (0, r.mergeOptions)(r.defaultOptions, n), !(0, r.shouldInterceptError)(o, n, e, s)) return Promise.reject(o);\n          n.pauseInstanceWhileRefreshing && s.skipInstances.push(e);\n          var u = (0, r.createRefreshCall)(o, t, s);\n          return (0, r.createRequestQueueInterceptor)(e, s, n), u.finally(function () {\n            return (0, r.unsetCache)(e, s);\n          }).catch(function (e) {\n            return Promise.reject(e);\n          }).then(function () {\n            return (0, r.resendFailedRequest)(o, (0, r.getRetryInstance)(e, n));\n          });\n        });\n      };\n    }(), s;\n  }();\n});","map":{"version":3,"sources":["webpack://axios-auth-refresh/webpack/universalModuleDefinition","webpack://axios-auth-refresh/src/utils.ts","webpack:/axios-auth-refresh/external umd \"axios\"","webpack://axios-auth-refresh/webpack/bootstrap","webpack://axios-auth-refresh/src/index.ts"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__300__","statusCodes","pauseInstanceWhileRefreshing","defaults","options","skipWhileRefreshing","error","instance","cache","config","skipAuthRefresh","interceptNetworkError","response","request","status","includes","parseInt","skipInstances","fn","refreshCall","then","console","warn","Promise","reject","requestQueueInterceptorId","interceptors","catch","Cancel","onRetry","eject","undefined","filter","retryInstance","__webpack_module_cache__","cachedModule","moduleId","__webpack_modules__","call","refreshAuthCall","Error","refreshing","finally"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"axios\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"axios\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"axios-auth-refresh\"] = factory(require(\"axios\"));\n\telse\n\t\troot[\"axios-auth-refresh\"] = factory(root[\"axios\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__300__) {\nreturn ","import axios, { AxiosInstance, AxiosPromise, AxiosRequestConfig } from 'axios';\nimport { AxiosAuthRefreshOptions, AxiosAuthRefreshCache } from './model';\n\nexport interface CustomAxiosRequestConfig extends AxiosRequestConfig {\n    skipAuthRefresh?: boolean\n}\n\nexport const defaultOptions: AxiosAuthRefreshOptions = {\n  statusCodes: [ 401 ],\n  pauseInstanceWhileRefreshing: false,\n};\n\n/**\n * Merges two options objects (options overwrites defaults).\n *\n * @return {AxiosAuthRefreshOptions}\n */\nexport function mergeOptions(\n  defaults: AxiosAuthRefreshOptions,\n    options: AxiosAuthRefreshOptions,\n): AxiosAuthRefreshOptions {\n  return {\n    ...defaults,\n    pauseInstanceWhileRefreshing: options.skipWhileRefreshing,\n    ...options,\n  };\n}\n\n/**\n * Returns TRUE: when error.response.status is contained in options.statusCodes\n * Returns FALSE: when error or error.response doesn't exist or options.statusCodes doesn't include response status\n *\n * @return {boolean}\n */\nexport function shouldInterceptError(\n    error: any,\n    options: AxiosAuthRefreshOptions,\n    instance: AxiosInstance,\n    cache: AxiosAuthRefreshCache,\n): boolean {\n  if (!error) {\n    return false;\n  }\n\n  if (error.config?.skipAuthRefresh) {\n    return false;\n  }\n\n  if (\n    !(options.interceptNetworkError && !error.response && error.request.status === 0) &&\n    (!error.response || !options.statusCodes?.includes(parseInt(error.response.status)))\n  ) {\n    return false;\n  }\n\n  // Copy config to response if there's a network error, so config can be modified and used in the retry\n  if (!error.response) {\n    error.response = {\n      config: error.config,\n    };\n  }\n\n  return !options.pauseInstanceWhileRefreshing || !cache.skipInstances.includes(instance);\n}\n\n/**\n * Creates refresh call if it does not exist or returns the existing one.\n *\n * @return {Promise<any>}\n */\nexport function createRefreshCall(\n    error: any,\n    fn: (error: any) => Promise<any>,\n    cache: AxiosAuthRefreshCache,\n): Promise<any> {\n  if (!cache.refreshCall) {\n    cache.refreshCall = fn(error);\n    if (typeof cache.refreshCall.then !== 'function') {\n      console.warn('axios-auth-refresh requires `refreshTokenCall` to return a promise.');\n      return Promise.reject();\n    }\n  }\n  return cache.refreshCall;\n}\n\n/**\n * Creates request queue interceptor if it does not exist and returns its id.\n *\n * @return {number}\n */\nexport function createRequestQueueInterceptor(\n    instance: AxiosInstance,\n    cache: AxiosAuthRefreshCache,\n    options: AxiosAuthRefreshOptions,\n): number {\n  if (typeof cache.requestQueueInterceptorId === 'undefined') {\n    cache.requestQueueInterceptorId = instance.interceptors.request.use((request: CustomAxiosRequestConfig) => {\n      if(request?.skipAuthRefresh)\n        return request\n      return cache.refreshCall\n          .catch(() => {\n            throw new axios.Cancel('Request call failed');\n          })\n          .then(() => options.onRetry ? options.onRetry(request) : request);\n    });\n  }\n  return cache.requestQueueInterceptorId;\n}\n\n/**\n * Ejects request queue interceptor and unset interceptor cached values.\n *\n * @param {AxiosInstance} instance\n * @param {AxiosAuthRefreshCache} cache\n */\nexport function unsetCache(\n    instance: AxiosInstance,\n    cache: AxiosAuthRefreshCache,\n): void {\n  instance.interceptors.request.eject(cache.requestQueueInterceptorId);\n  cache.requestQueueInterceptorId = undefined;\n  cache.refreshCall = undefined;\n  cache.skipInstances = cache.skipInstances.filter(skipInstance => skipInstance !== instance);\n}\n\n/**\n * Returns instance that's going to be used when requests are retried\n *\n * @param instance\n * @param options\n */\nexport function getRetryInstance(instance: AxiosInstance, options: AxiosAuthRefreshOptions): AxiosInstance {\n  return options.retryInstance || instance;\n}\n\n/**\n * Resend failed axios request.\n *\n * @param {any} error\n * @param {AxiosInstance} instance\n * @return AxiosPromise\n */\nexport function resendFailedRequest(\n    error: any,\n    instance: AxiosInstance\n): AxiosPromise {\n  error.config.skipAuthRefresh = true;\n  return instance(error.response.config);\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__300__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { AxiosInstance, AxiosResponse } from 'axios';\nimport { AxiosAuthRefreshOptions, AxiosAuthRefreshCache } from './model';\nimport {\n    unsetCache,\n    mergeOptions,\n    defaultOptions,\n    getRetryInstance,\n    createRefreshCall,\n    resendFailedRequest,\n    shouldInterceptError,\n    createRequestQueueInterceptor,\n} from './utils';\n\nexport { AxiosAuthRefreshOptions, AxiosAuthRefreshRequestConfig } from './model';\n\n/**\n * Creates an authentication refresh interceptor that binds to any error response.\n * If the response status code is one of the options.statusCodes, interceptor calls the refreshAuthCall\n * which must return a Promise. While refreshAuthCall is running, all the new requests are intercepted and are waiting\n * for the refresh call to resolve. While running the refreshing call, instance provided is marked as a paused instance\n * which indicates the interceptor to not intercept any responses from it. This is because you'd otherwise need to mark\n * the specific requests you make by yourself in order to make sure it's not intercepted. This behavior can be\n * turned off, but use it with caution as you need to mark the requests with `skipAuthRefresh` flag yourself in order to\n * not run into interceptors loop.\n *\n * @param {AxiosInstance} instance - Axios HTTP client instance\n * @param {(error: any) => Promise<AxiosPromise>} refreshAuthCall - refresh token call which must return a Promise\n * @param {AxiosAuthRefreshOptions} options - options for the interceptor @see defaultOptions\n * @return {number} - interceptor id (in case you want to eject it manually)\n */\nexport default function createAuthRefreshInterceptor(\n    instance: AxiosInstance,\n    refreshAuthCall: (error: any) => Promise<any>,\n    options: AxiosAuthRefreshOptions = {},\n): number {\n\n    if (typeof refreshAuthCall !== 'function') {\n        throw new Error('axios-auth-refresh requires `refreshAuthCall` to be a function that returns a promise.');\n    }\n\n    const cache: AxiosAuthRefreshCache = {\n        skipInstances: [],\n        refreshCall: undefined,\n        requestQueueInterceptorId: undefined,\n    };\n\n    return instance.interceptors.response.use((response: AxiosResponse) => response, (error: any) => {\n\n        options = mergeOptions(defaultOptions, options);\n\n        if (!shouldInterceptError(error, options, instance, cache)) {\n            return Promise.reject(error);\n        }\n\n        if (options.pauseInstanceWhileRefreshing) {\n            cache.skipInstances.push(instance);\n        }\n\n        // If refresh call does not exist, create one\n        const refreshing = createRefreshCall(error, refreshAuthCall, cache);\n\n        // Create interceptor that will bind all the others requests until refreshAuthCall is resolved\n        createRequestQueueInterceptor(instance, cache, options);\n\n        return refreshing\n            .finally(() => unsetCache(instance, cache))\n            .catch(error => Promise.reject(error))\n            .then(() => resendFailedRequest(error, getRetryInstance(instance, options)));\n    });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}